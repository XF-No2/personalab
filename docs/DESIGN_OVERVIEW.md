# PersonaLab 概要设计文档

**文档类型**: 概要设计（Architecture Overview）
**版本**: v0.3.0
**最后更新**: 2025-10-15
**状态**: 🟡 设计中

> 📌 **重要**: 这是概要设计文档，只描述架构框架、核心流程和设计原则。
> 不包含具体实现细节、代码示例和性能数值。

---

## 1. 项目概述

PersonaLab（人格实验室）是一个 **AI 角色对话平台**，支持长篇、高一致性、角色可成长的互动叙事。

### 核心目标

1. **支持长对话** - 对话可持续数百轮，通过汇总功能延续
2. **角色成长** - 角色人格随对话经历动态演化
3. **剧情控制** - 导演模块确保 AI 遵循主线大纲
4. **用户控制** - 所有维护操作（汇总、更新记忆）由用户主动触发

### 技术选型

**前端**: Next.js 14 + TypeScript + Shadcn/ui + Socket.IO
**后端**: Python 3.11+ + FastAPI + LangChain + Chroma

---

## 2. 核心架构

### 2.1 数据架构（三层）

```
PersonaLab 数据架构
├─ 角色状态（Character State）
│   - 存储：character_state.json
│   - 内容：base_persona（初始人格）+ evolved_persona（成长人格）
│   - 更新：用户手动触发（"🧠 更新记忆"按钮）
│
├─ 事件库（Event Library）
│   - 存储：Chroma 向量数据库
│   - 内容：每次汇总生成的多段情节摘要
│   - 作用：RAG 检索历史事件（跨多次汇总）
│   - 写入：汇总时自动写入
│
└─ 对话历史（Conversation History）
    - 存储：.jsonl 文件（当前会话）
    - 内容：用户和 AI 的完整对话记录
    - 读取：每次全量读取所有对话
    - 汇总：汇总后关闭旧会话，开启新会话
```

### 2.2 会话实例架构

**核心概念**：会话实例是状态隔离容器

```
角色定义（全局）
  └─ 会话实例 1
      ├─ 角色状态（独立）
      └─ 多个会话
          ├─ session_001（已汇总）
          ├─ session_002（已汇总）
          └─ session_003（当前活跃）
```

**关键点**：
- 同一角色可以创建多个会话实例（不同剧情线）
- 每个会话实例的角色状态完全独立
- 一个会话实例内可以有多个会话（通过汇总功能延续）

---

## 3. 核心流程

### 3.1 对话交互流程

```
用户输入
  ↓
[1] 追加到会话文件
  ↓
[2] 并行加载数据
  - RAG 检索相关历史事件（Chroma）
  - 加载角色状态（base_persona + evolved_persona）
  - 加载背景设定
  - 全量读取当前会话对话历史
  ↓
[3] 组装 Prompt
  - 角色人格
  - 背景设定
  - RAG 检索到的历史事件
  - 当前会话的全部对话
  - 用户输入
  ↓
[4] 调用 LLM（流式输出）
  ↓
[5] 追加 AI 回复到会话文件
  ↓
[6] 返回前端
```

**设计原则**：
- ✅ 单一数据源（只维护 .jsonl 文件）
- ✅ 全量读取对话历史（不限制数量）
- ✅ 无自动维护任务（不自动更新人格、不自动汇总）

---

### 3.2 汇总功能流程

**触发**: 用户点击"📝 汇总对话"按钮

```
汇总功能流程
  ↓
[1] 全量读取当前会话所有对话
  ↓
[2] 调用汇总 Agent（独立 LLM 调用）
  - Prompt: "请把以下对话按照情节点进行汇总"
  - 返回: 多段分段的纯文本摘要
  - 示例:
      第一段：情报交换
      用户告知 Alserqi 北区据点有背叛者...

      第二段：制定计划
      Alserqi 决定前往调查...

      第三段：关系深化
      通过对话，Alserqi 对用户产生信任...
  ↓
[3] 解析多段摘要
  ↓
[4] 每段分别写入 Chroma 事件库
  - 字段结构预留扩展性（待后续确定）
  ↓
[5] 关闭当前会话（标记为 summarized）
  ↓
[6] 创建新会话
  - 初始化内容:
      方案A（可配置）: 多段摘要 + 最后5轮对话
      方案B（可配置）: 最后5轮对话 + 多段摘要
  ↓
[7] 返回前端，自动切换到新会话
```

**关键点**：
- 汇总 Agent 是独立的 LLM 调用（纯粹的对话总结）
- 返回多段分段的纯文本（不是结构化数据）
- 每段分别存入 Chroma，支持 RAG 跨会话检索
- 摘要格式预留扩展性（后续可强调格式要求）

---

### 3.3 手动更新记忆流程

**触发**: 用户点击"🧠 更新记忆"按钮

```
更新记忆流程
  ↓
[1] 加载当前角色状态
  ↓
[2] 全量读取当前会话对话
  ↓
[3] 调用 LLM 更新 evolved_persona
  - 输入: base_persona + old_evolved_persona + 对话历史
  - 输出: new_evolved_persona
  ↓
[4] 保存新的 evolved_persona
  ↓
[5] 同时生成事件摘要并写入 Chroma（可选）
  ↓
[6] 返回前端
```

**与汇总功能的区别**：
- **汇总功能**: 总结对话内容，创建新会话延续
- **更新记忆**: 更新角色人格状态（evolved_persona）

---

### 3.4 回退重新生成流程

**触发**: 用户点击"⬅️ 回退 N 步"按钮

```
回退流程
  ↓
[1] 读取会话文件
  ↓
[2] 删除最后 N 轮对话（N 轮 = 2N 条消息）
  ↓
[3] 重写会话文件
  ↓
[4] 返回前端，用户可重新输入
```

**设计原则**：
- 单一数据源，只需修改 .jsonl 文件
- 不需要同步更新缓存（因为没有缓存）

---

## 4. 导演模块

### 核心职责

控制剧情推进，确保 AI 不偏离主线大纲。

### 三层控制机制

```
1. 静态约束
   - 主线大纲（10个情节点）全量放入 Prompt 头部 4K
   - JSON 格式，始终可见

2. 动态引导
   - AI 每次回复输出 [PROGRESS:X:status] 标记
   - 后端正则扫描，更新剧情状态

3. RAG 兜底
   - 连续 3 轮未更新剧情状态 → 触发兜底机制
   - 分层检索：当前实例 15 条 + 其他实例 5 条
   - 注入 Prompt 提醒 AI 回归主线
```

**扩展性**: 导演模块是框架，未来可扩展更多控制机制。

---

## 5. RAG 检索策略

### 检索场景

**场景1: 日常对话**
- 只检索当前实例的事件（严格隔离）
- 返回 20 条相关事件

**场景2: 导演兜底**
- 跨实例检索（借鉴其他实例经验）
- 分两次查询：
  - 当前实例 15 条
  - 其他实例 5 条
- Prompt 中明确区分"当前剧情事实"和"剧情经验参考"

### 事件过滤

所有 RAG 检索必须过滤 `instance_id`，避免不同会话实例的事件混淆。

---

## 6. 角色人格机制

### 数据结构

```json
{
  "base_persona": "角色的初始人格，永不改变",
  "evolved_persona": "角色经历成长后的状态，手动更新",
  "last_maintenance_turn": 150
}
```

### 两层人格

1. **base_persona（初始人格）**
   - 角色的底色，永不改变
   - 包含：原型、核心目标、核心特质、背景故事

2. **evolved_persona（成长人格）**
   - 随对话经历动态演化
   - 由用户手动触发更新
   - 包含：信念变化、行为模式、关系深度、当前情绪等
   - **纯定性描述**，不使用量化数值

### Prompt 组装

```
---CHARACTER_PERSONA---
## Base Identity (Immutable Core) ##
{base_persona}

## Evolved State (Growth Through Experience) ##
{evolved_persona}

## Recent Context ##
{当前会话的全部对话}
---
```

---

## 7. 数据存储结构

### 目录结构

```
data/
├── characters/              # 角色库（全局）
│   └── {character_id}/
│       └── definition.json
│
├── backgrounds/             # 背景库（全局）
│   └── {background_id}/
│       └── background.json
│
├── instances/               # 会话实例（核心）
│   └── {instance_id}/
│       ├── metadata.json
│       ├── character_state.json
│       └── sessions/
│           ├── session_001.jsonl
│           ├── session_002.jsonl
│           └── session_003.jsonl
│
├── event_library/           # 事件库
│   └── chroma_db/
│
└── prompt_templates/        # Prompt 模板（可配置）
```

### 会话文件格式（.jsonl）

```jsonl
{"type":"metadata","instance_id":"inst_001","session_id":"sess_001","status":"active","created_at":"...","continued_from":null}
{"role":"user","content":"你好","turn":1,"timestamp":"..."}
{"role":"assistant","content":"你好，有什么事吗？","turn":1,"timestamp":"..."}
{"role":"user","content":"你还记得我之前说的话吗？","turn":2,"timestamp":"..."}
```

**metadata 字段**：
- `status`: "active" / "closed" / "summarized"
- `continued_from`: 如果是汇总后的新会话，记录旧会话 ID

---

## 8. 配置系统

### 配置文件（预留）

```json
{
  "summary": {
    "order": "summary_first",  // 或 "last_5_first"
    "last_n_turns": 5
  },
  "recall_memory": {
    "load_all": true,
    "max_tokens": 100000
  },
  "director": {
    "enabled": true,
    "rag_fallback_threshold": 3
  }
}
```

---

## 9. 核心设计原则

### 单一数据源原则
- 只维护 .jsonl 文件，不维护内存缓存
- 避免数据同步问题
- 支持回退功能

### 完全手动触发原则
- 汇总功能：用户主动触发
- 更新记忆：用户主动触发
- 不自动维护，用户完全控制

### 预留扩展性原则
- 汇总摘要格式待定，预留扩展字段
- Prompt 模板可配置
- 配置系统支持运行时调整

### 纯定性描述原则
- 角色状态使用自然语言描述
- 不使用 priority、intensity、level 等量化数值
- 符合人类理解习惯

---

## 10. 关键技术决策

### 已确定

1. ✅ **取消 RecallMemoryCache**（内存缓存）→ 全量读取对话
2. ✅ **取消定期自动维护**（Core Memory、事件写入）→ 完全手动触发
3. ✅ **取消滑动窗口机制** → 不限制对话数量
4. ✅ **汇总功能**：独立 LLM Agent，生成多段情节摘要
5. ✅ **RAG 事件库**：存储汇总摘要，支持跨会话检索
6. ✅ **回退功能**：支持删除最近 N 轮对话

### 待确定

1. ⏳ 汇总摘要的具体格式和字段结构
2. ⏳ Prompt 模板的详细设计
3. ⏳ 导演模块"拉回主线"的具体策略
4. ⏳ 性能优化的具体措施

---

## 11. 后续工作

### 短期

1. 确认概要设计（本文档）
2. 设计后端 API 接口规范
3. 设计前端 UI 交互流程

### 中期

1. 实现后端核心模块
2. 实现前端核心组件
3. 前后端联调

### 长期

1. 完善详细设计文档（按需）
2. 性能测试和优化
3. V1.0 发布

---

**文档版本**: v0.3.0
**创建日期**: 2025-10-15
**文档类型**: 概要设计（不含详细实现）
